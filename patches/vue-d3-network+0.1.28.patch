diff --git a/node_modules/vue-d3-network/src/vue-d3-network.vue b/node_modules/vue-d3-network/src/vue-d3-network.vue
index cc2aaeb..4b9b7fd 100644
--- a/node_modules/vue-d3-network/src/vue-d3-network.vue
+++ b/node_modules/vue-d3-network/src/vue-d3-network.vue
@@ -1,68 +1,68 @@
 <script>
-import * as forceSimulation from 'd3-force'
-import svgRenderer from './components/svgRenderer.vue'
-import canvasRenderer from './components/canvasRenderer.vue'
-import saveImage from './lib/js/saveImage.js'
-import svgExport from './lib/js/svgExport.js'
-const d3 = Object.assign({}, forceSimulation)
+import * as forceSimulation from "d3-force";
+import svgRenderer from "./components/svgRenderer.vue";
+import canvasRenderer from "./components/canvasRenderer.vue";
+import saveImage from "./lib/js/saveImage.js";
+import svgExport from "./lib/js/svgExport.js";
+const d3 = Object.assign({}, forceSimulation);
 
 export default {
-  name: 'd3-network',
+  name: "d3-network",
   components: {
     canvasRenderer,
-    svgRenderer
+    svgRenderer,
   },
   props: {
     netNodes: {
-      type: Array
+      type: Array,
     },
     netLinks: {
-      type: Array
+      type: Array,
     },
     options: {
-      type: Object
+      type: Object,
     },
     nodeSym: {
-      type: String
+      type: String,
     },
     nodeCb: {
-      type: Function
+      type: Function,
     },
     linkCb: {
-      type: Function
+      type: Function,
     },
     simCb: {
-      type: Function
+      type: Function,
     },
     customForces: {
-      type: Object
+      type: Object,
     },
     selection: {
       type: Object,
       default: () => {
         return {
           nodes: {},
-          links: {}
-        }
-      }
-    }
+          links: {},
+        };
+      },
+    },
   },
-  data () {
+  data() {
     return {
       canvas: false,
       nodes: [],
       links: [],
       size: {
         w: 500,
-        h: 500
+        h: 500,
       },
       offset: {
         x: 0,
-        y: 0
+        y: 0,
       },
       clientOffset: {
         x: 0,
-        y: 0
+        y: 0,
       },
       force: 500,
       forces: {
@@ -70,7 +70,7 @@ export default {
         X: 0.5,
         Y: 0.5,
         ManyBody: true,
-        Link: true
+        Link: true,
       },
       noNodes: false,
       strLinks: true,
@@ -82,366 +82,400 @@ export default {
       nodeSize: 5,
       mouseOfst: {
         x: 0,
-        y: 0
+        y: 0,
       },
       padding: {
         x: 0,
-        y: 0
+        y: 0,
       },
       simulation: null,
       nodeSvg: null,
-      resizeListener: true
-    }
+      resizeListener: true,
+    };
   },
-  render (createElement) {
-    let ref = 'svg'
-    let props = {}
-    let renderer = 'svg-renderer'
+  render(createElement) {
+    let ref = "svg";
+    let props = {};
+    let renderer = "svg-renderer";
     let bindProps = [
-      'size',
-      'nodes',
-      'links',
-      'selected',
-      'linksSelected',
-      'strLinks',
-      'linkWidth',
-      'nodeLabels',
-      'linkLabels',
-      'fontSize',
-      'labelOffset',
-      'offset',
-      'padding',
-      'nodeSize',
-      'noNodes'
-    ]
+      "size",
+      "nodes",
+      "links",
+      "selected",
+      "linksSelected",
+      "strLinks",
+      "linkWidth",
+      "nodeLabels",
+      "linkLabels",
+      "fontSize",
+      "labelOffset",
+      "offset",
+      "padding",
+      "nodeSize",
+      "noNodes",
+    ];
 
     for (let prop of bindProps) {
-      props[prop] = this[prop]
+      props[prop] = this[prop];
     }
-    props.nodeSym = this.nodeSvg
+    props.nodeSym = this.nodeSvg;
 
     if (this.canvas) {
-      renderer = 'canvas-renderer'
-      ref = 'canvas'
-      props.canvasStyles = this.options.canvasStyles
+      renderer = "canvas-renderer";
+      ref = "canvas";
+      props.canvasStyles = this.options.canvasStyles;
     }
 
-    return createElement('div', {
-      attrs: { class: 'net' },
-      on: { 'mousemove': this.move, '&touchmove': this.move }
-    }, [createElement(renderer, {
-      props, ref, on: { action: this.methodCall }
-    })])
+    return createElement(
+      "div",
+      {
+        attrs: { class: "net" },
+        on: { mousemove: this.move, "&touchmove": this.move },
+      },
+      [
+        createElement(renderer, {
+          props,
+          ref,
+          on: { action: this.methodCall },
+        }),
+      ]
+    );
   },
-  created () {
-    this.updateOptions(this.options)
-    this.buildNodes(this.netNodes)
-    this.links = this.buildLinks(this.netLinks)
-    this.updateNodeSvg()
+  created() {
+    this.updateOptions(this.options);
+    this.buildNodes(this.netNodes);
+    this.links = this.buildLinks(this.netLinks);
+    this.updateNodeSvg();
   },
-  mounted () {
-    this.onResize()
+  mounted() {
+    this.onResize();
     this.$nextTick(() => {
-      this.animate()
-    })
-    if (this.resizeListener) window.addEventListener('resize', this.onResize)
+      this.animate();
+    });
+    if (this.resizeListener) window.addEventListener("resize", this.onResize);
   },
-  beforeDestroy () {
-    if (this.resizeListener) window.removeEventListener('resize', this.onResize)
+  beforeDestroy() {
+    if (this.resizeListener)
+      window.removeEventListener("resize", this.onResize);
   },
   computed: {
-    selected () {
-      return this.selection.nodes
+    selected() {
+      return this.selection.nodes;
     },
-    linksSelected () {
-      return this.selection.links
+    linksSelected() {
+      return this.selection.links;
     },
-    center () {
+    center() {
       return {
-        x: this.size.w / 2 + (this.size.w / 200) + this.offset.x,
-        y: this.size.h / 2 + (this.size.h / 200) + this.offset.y
-      }
+        x: this.size.w / 2 + this.size.w / 200 + this.offset.x,
+        y: this.size.h / 2 + this.size.h / 200 + this.offset.y,
+      };
     },
-    labelOffset () {
+    labelOffset() {
       return {
-        x: (this.nodeSize / 2) + (this.fontSize / 2),
-        y: this.fontSize / 2
-      }
-    }
+        x: this.nodeSize / 2 + this.fontSize / 2,
+        y: this.fontSize / 2,
+      };
+    },
   },
   watch: {
-    netNodes (newValue) {
-      this.buildNodes(newValue)
-      this.reset()
+    netNodes(newValue) {
+      this.buildNodes(newValue);
+      this.reset();
     },
-    netLinks (newValue, oldValue) {
-      this.links = this.buildLinks(newValue)
-      this.reset()
+    netLinks(newValue, oldValue) {
+      this.links = this.buildLinks(newValue);
+      this.reset();
     },
-    nodeSym () {
-      this.updateNodeSvg()
+    nodeSym() {
+      this.updateNodeSvg();
     },
-    options (newValue, oldValue) {
-      this.updateOptions(newValue)
+    options(newValue, oldValue) {
+      this.updateOptions(newValue);
       if (oldValue.size && newValue.size) {
-        if ((oldValue.size.w !== newValue.size.w) || (oldValue.size.h !== newValue.size.h)) {
-          this.onResize()
+        if (
+          oldValue.size.w !== newValue.size.w ||
+          oldValue.size.h !== newValue.size.h
+        ) {
+          this.onResize();
         }
       }
-      this.animate()
-    }
+      this.animate();
+    },
   },
   methods: {
-    updateNodeSvg () {
-      let svg = null
+    updateNodeSvg() {
+      let svg = null;
       if (this.nodeSym) {
-        svg = svgExport.svgElFromString(this.nodeSym)
+        svg = svgExport.svgElFromString(this.nodeSym);
       }
-      this.nodeSvg = svg
+      this.nodeSvg = svg;
     },
-    methodCall (action, args) {
-      let method = this[action]
-      if (method && typeof (method) === 'function') {
-        if (args) method(...args)
-        else method()
+    methodCall(action, args) {
+      let method = this[action];
+      if (method && typeof method === "function") {
+        if (args) method(...args);
+        else method();
       }
     },
-    onResize () {
-      let size = this.options.size
-      if (!size || !size.w) this.size.w = this.$el.clientWidth
-      if (!size || !size.h) this.size.h = this.$el.clientHeight
-      this.padding.x = 0
-      this.padding.y = 0
+    onResize() {
+      let size = this.options.size;
+      if (!size || !size.w) this.size.w = this.$el.clientWidth;
+      if (!size || !size.h) this.size.h = this.$el.clientHeight;
+      this.padding.x = 0;
+      this.padding.y = 0;
       // serach offsets of parents
-      let vm = this
+      let vm = this;
       while (vm.$parent) {
-        this.padding.x += vm.$el.offsetLeft || 0
-        this.padding.y += vm.$el.offsetTop || 0
-        vm = vm.$parent
+        this.padding.x += vm.$el.offsetLeft || 0;
+        this.padding.y += vm.$el.offsetTop || 0;
+        vm = vm.$parent;
       }
-      this.animate()
+      this.animate();
     },
     // -- Data
-    updateOptions (options) {
+    updateOptions(options) {
       for (let op in options) {
-        if (this.hasOwnProperty(op)) {
-          this[op] = options[op]
+        if (this[op]) {
+          this[op] = options[op];
         }
       }
     },
-    buildNodes (nodes) {
-      let vm = this
+    buildNodes(nodes) {
+      let vm = this;
       this.nodes = nodes.map((node, index) => {
         // node formatter option
-        node = this.itemCb(this.nodeCb, node)
+        node = this.itemCb(this.nodeCb, node);
         // index as default node id
-        if (!node.id && node.id !== 0) vm.$set(node, 'id', index)
+        if (!node.id && node.id !== 0) vm.$set(node, "id", index);
         // initialize node coords
-        if (!node.x) vm.$set(node, 'x', 0)
-        if (!node.y) vm.$set(node, 'y', 0)
+        if (!node.x) vm.$set(node, "x", 0);
+        if (!node.y) vm.$set(node, "y", 0);
         // node default name, allow string 0 as name
-        if (!node.name && node.name !== '0') vm.$set(node, 'name', 'node ' + node.id)
+        if (!node.name && node.name !== "0")
+          vm.$set(node, "name", "node " + node.id);
         if (node.svgSym) {
-          node.svgIcon = svgExport.svgElFromString(node.svgSym)
-          if (!this.canvas && node.svgIcon && !node.svgObj) node.svgObj = svgExport.toObject(node.svgIcon)
+          node.svgIcon = svgExport.svgElFromString(node.svgSym);
+          if (!this.canvas && node.svgIcon && !node.svgObj)
+            node.svgObj = svgExport.toObject(node.svgIcon);
         }
-        return node
-      })
+        return node;
+      });
     },
 
-    buildLinks (links) {
-      let vm = this
+    buildLinks(links) {
+      let vm = this;
       return links.concat().map((link, index) => {
         // link formatter option
-        link = this.itemCb(this.linkCb, link)
+        link = this.itemCb(this.linkCb, link);
         // source and target for d3
-        link.source = link.sid
-        link.target = link.tid
-        if (!link.id) vm.$set(link, 'id', 'link-' + index)
-        return link
-      })
+        link.source = link.sid;
+        link.target = link.tid;
+        if (!link.id) vm.$set(link, "id", "link-" + index);
+        return link;
+      });
     },
-    itemCb (cb, item) {
-      if (cb && typeof (cb) === 'function') item = cb(item)
-      return item
+    itemCb(cb, item) {
+      if (cb && typeof cb === "function") item = cb(item);
+      return item;
     },
     // -- Animation
-    simulate (nodes, links) {
-      let forces = this.forces
-      let sim = d3.forceSimulation()
+    simulate(nodes, links) {
+      let forces = this.forces;
+      let sim = d3
+        .forceSimulation()
         .stop()
         .alpha(0.5)
         // .alphaMin(0.05)
-        .nodes(nodes)
+        .nodes(nodes);
 
-      if (forces.Center !== false) sim.force('center', d3.forceCenter(this.center.x, this.center.y))
+      if (forces.Center !== false)
+        sim.force("center", d3.forceCenter(this.center.x, this.center.y));
       if (forces.X !== false) {
-        sim.force('X', d3.forceX(this.center.x).strength(forces.X))
+        sim.force("X", d3.forceX(this.center.x).strength(forces.X));
       }
       if (forces.Y !== false) {
-        sim.force('Y', d3.forceY(this.center.y).strength(forces.Y))
+        sim.force("Y", d3.forceY(this.center.y).strength(forces.Y));
       }
       if (forces.ManyBody !== false) {
-        sim.force('charge', d3.forceManyBody().strength(-this.force))
+        sim.force("charge", d3.forceManyBody().strength(-this.force));
       }
       if (forces.Link !== false) {
-        sim.force('link', d3.forceLink(links).id(function (d) { return d.id }))
+        sim.force(
+          "link",
+          d3.forceLink(links).id(function (d) {
+            return d.id;
+          })
+        );
       }
-      sim = this.setCustomForces(sim)
-      sim = this.itemCb(this.simCb, sim)
-      return sim
+      sim = this.setCustomForces(sim);
+      sim = this.itemCb(this.simCb, sim);
+      return sim;
     },
-    setCustomForces (sim) {
-      let forces = this.customForces
+    setCustomForces(sim) {
+      let forces = this.customForces;
       if (forces) {
         for (let f in forces) {
-          let d3Func = this.getD3Func('force' + f)
+          let d3Func = this.getD3Func("force" + f);
           if (d3Func) {
-            let args = forces[f]
-            sim.force('custom' + f, d3Func(...args))
+            let args = forces[f];
+            sim.force("custom" + f, d3Func(...args));
           }
         }
       }
-      return sim
+      return sim;
     },
-    getD3Func (name) {
-      let func = d3[name]
-      if (func && typeof (func) === 'function') return func
-      return null
+    getD3Func(name) {
+      let func = d3[name];
+      if (func && typeof func === "function") return func;
+      return null;
     },
-    animate () {
-      if (this.simulation) this.simulation.stop()
-      if (this.forces.Link !== false) this.simulation = this.simulate(this.nodes, this.links)
-      else this.simulation = this.simulate(this.nodes)
-      this.simulation.restart()
+    animate() {
+      if (this.simulation) this.simulation.stop();
+      if (this.forces.Link !== false)
+        this.simulation = this.simulate(this.nodes, this.links);
+      else this.simulation = this.simulate(this.nodes);
+      this.simulation.restart();
     },
-    reset () {
-      this.animate()
-      this.nodes = this.simulation.nodes()
-      if (this.forces.links) this.links = this.simulation.force('link').links()
+    reset() {
+      this.animate();
+      this.nodes = this.simulation.nodes();
+      if (this.forces.links) this.links = this.simulation.force("link").links();
     },
     // -- Mouse Interaction
-    move (event) {
-      let pos = this.clientPos(event)
+    move(event) {
+      let pos = this.clientPos(event);
       if (this.dragging !== false) {
         if (this.nodes[this.dragging]) {
-          this.simulation.restart()
-          this.simulation.alpha(0.5)
-          this.nodes[this.dragging].fx = pos.x - this.mouseOfst.x
-          this.nodes[this.dragging].fy = pos.y - this.mouseOfst.y
+          this.simulation.restart();
+          this.simulation.alpha(0.5);
+          this.nodes[this.dragging].fx = pos.x - this.mouseOfst.x;
+          this.nodes[this.dragging].fy = pos.y - this.mouseOfst.y;
         }
       }
     },
-    clientPos (event) {
-      let x = (event.touches) ? event.touches[0].clientX : event.clientX
-      let y = (event.touches) ? event.touches[0].clientY : event.clientY
-      x = x || 0
-      y = y || 0
-      return { x, y }
+    clientPos(event) {
+      let x = event.touches ? event.touches[0].clientX : event.clientX;
+      let y = event.touches ? event.touches[0].clientY : event.clientY;
+      x = x || 0;
+      y = y || 0;
+      return { x, y };
     },
-    dragStart (event, nodeKey) {
-      this.dragging = (nodeKey === false) ? false : nodeKey
-      this.setMouseOffset(event, this.nodes[nodeKey])
+    dragStart(event, nodeKey) {
+      this.dragging = nodeKey === false ? false : nodeKey;
+      this.setMouseOffset(event, this.nodes[nodeKey]);
       if (this.dragging === false) {
-        this.simulation.alpha(0.1)
-        this.simulation.restart()
-        this.setMouseOffset()
+        this.simulation.alpha(0.1);
+        this.simulation.restart();
+        this.setMouseOffset();
       }
     },
-    dragEnd () {
-      let node = this.nodes[this.dragging]
+    dragEnd() {
+      let node = this.nodes[this.dragging];
       if (node && !node.pinned) {
         // unfix node position
-        node.fx = null
-        node.fy = null
+        node.fx = null;
+        node.fy = null;
       }
-      this.dragStart(false)
+      this.dragStart(false);
     },
     // -- Render helpers
-    nodeClick (event, node) {
-      this.$emit('node-click', event, node)
+    nodeClick(event, node) {
+      this.$emit("node-click", event, node);
     },
-    linkClick (event, link) {
-      this.$emit('link-click', event, link)
+    linkClick(event, link) {
+      this.$emit("link-click", event, link);
     },
-    setMouseOffset (event, node) {
-      let x = 0
-      let y = 0
+    setMouseOffset(event, node) {
+      let x = 0;
+      let y = 0;
       if (event && node) {
-        let pos = this.clientPos(event)
-        x = (pos.x) ? pos.x - node.x : node.x
-        y = (pos.y) ? pos.y - node.y : node.y
+        let pos = this.clientPos(event);
+        x = pos.x ? pos.x - node.x : node.x;
+        y = pos.y ? pos.y - node.y : node.y;
       }
-      this.mouseOfst = { x, y }
+      this.mouseOfst = { x, y };
     },
-    screenShot (name, bgColor, toSVG, svgAllCss) {
-      let exportFunc
-      let args = []
+    screenShot(name, bgColor, toSVG, svgAllCss) {
+      let exportFunc;
+      let args = [];
       if (this.canvas) {
-        toSVG = false
-        exportFunc = this.$refs.canvas.canvasScreenShot
-        args = [bgColor]
+        toSVG = false;
+        exportFunc = this.$refs.canvas.canvasScreenShot;
+        args = [bgColor];
       } else {
-        exportFunc = this.$refs.svg.svgScreenShot
-        args = [toSVG, bgColor, svgAllCss]
+        exportFunc = this.$refs.svg.svgScreenShot;
+        args = [toSVG, bgColor, svgAllCss];
       }
-      if (toSVG) name = name || 'export.svg'
+      if (toSVG) name = name || "export.svg";
 
       exportFunc((err, url) => {
         if (!err) {
-          if (!toSVG) saveImage.save(url, name)
-          else saveImage.download(url, name)
+          if (!toSVG) saveImage.save(url, name);
+          else saveImage.download(url, name);
         }
-        this.$emit('screen-shot', err)
-      }, ...args)
-    }
-  }
-}
+        this.$emit("screen-shot", err);
+      }, ...args);
+    },
+  },
+};
 </script>
 
 <style lang="stylus">
-  @import 'lib/styl/vars.styl'
+@import 'lib/styl/vars.styl';
 
-  .net
-    height 100%
-    margin 0
+.net {
+  height: 100%;
+  margin: 0;
+}
 
-  .net-svg
-    // fill: white // background color to export as image
+.net-svg {
+  // fill: white // background color to export as image
+}
 
-  .node
-    stroke alpha($dark, 0.7)
-    stroke-width 3px
-    transition fill 0.5s ease
-    fill $white
+.node {
+  stroke: alpha($dark, 0.7);
+  stroke-width: 3px;
+  transition: fill 0.5s ease;
+  fill: $white;
+}
 
-  .node.selected
-    stroke $color2
+.node.selected {
+  stroke: $color2;
+}
 
-  .node.pinned
-    stroke alpha($warn, 0.6)
+.node.pinned {
+  stroke: alpha($warn, 0.6);
+}
 
-  .link
-    stroke alpha($dark, 0.3)
+.link {
+  stroke: alpha($dark, 0.3);
+}
 
-  .node, .link
-    stroke-linecap round
+.node, .link {
+  stroke-linecap: round;
 
-    &:hover
-      stroke $warn
-      stroke-width 5px
+  &:hover {
+    stroke: $warn;
+    stroke-width: 5px;
+  }
+}
 
-  .link.selected
-    stroke alpha($color2, 0.6)
+.link.selected {
+  stroke: alpha($color2, 0.6);
+}
 
-  .curve
-    fill none
+.curve {
+  fill: none;
+}
 
-  .node-label
-    fill $dark
+.node-label {
+  fill: $dark;
+}
 
-  .link-label
-    fill $dark
-    transform translate(0, -0.5em)
-    text-anchor middle
+.link-label {
+  fill: $dark;
+  transform: translate(0, -0.5em);
+  text-anchor: middle;
+}
 </style>
